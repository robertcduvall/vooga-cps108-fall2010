#summary Discuss each Game in context of trying to create a coherent design.

= Introduction =

For each game listed below, your team should review its own game and the next game alphabetically. Your review should focus on how the game can be improved (or simplified) by using the VOOGA (or GTGE) APIs. The comments should generally be constructive in helping us to build a consensus API platform on which to build more complex games. Your review should include the entire game, not just the one class that extends Game.


== Cyberion ==

Our game, Cyberion, is a very simple and fun game in which you control a ship that tries to stay alive by either shooting the enemy ships down or simply avoiding the enemy ships and their "bullets".  There are bonuses you can recieve to increase your firepower to make it easier to shoot the enemy ships.

Our main method (other than update and render) in the main game class is initResources.  This method then calls various other methods which set sprites, collision detection, and event managers.  We created a collision group and manager for each possible collision using Golden T's built-in collision manager.

One thing we can improve on is making the code more dynamic.  For example, we hard-code each image file path.  In general, we have many sections with almost identical code, such as creating a collision manager for each collision type.  Another thing is using more of the Vooga API.  Right now we are only using the Event Manager API.

-Cyberion Team

== Doodle Jump ==

We would review Doodle Jump very similarly to our game (Cyberion).  It is a good game with the same general principals of initialization and collision detection.  Also, just like ours, they need to worry about making the code more dynamic and removing repetitive code and method calls.  They did use more APIs than us, but could still probably incorporate more, especially once they are improved.

-Cyberion Team

== Galaxy Invaders ==

Our game, GalaxyInvaders, initially did not use many of the APIs from VOOGA, as we found it simpler (and faster) to implement their functionalities ourselves. We are going to change this in refactoring, and replace our custom-built Level class, for example, with an extension of the Levels API. The APIs we did use, however, we found to be quite useful, including the Player and Overlay groups’, which fit in with our game pretty well. Clearly, our next step is to replace our code with as much API code as possible, including using the Events API more extensively, and the Resources API to handle all of our images and possibly our level files.

One of the APIs we do not really envision a need for is the Collisions API, as collisions are handled automatically by the GTGE. We, along with most groups, implemented them directly via GoldenT and they worked quite well. While we understand that this API could in theory provide easier functionality, in its current state it seems to require even more code (such as extending Collidable) than the GTGE built-in detection.

Our code is still somewhat rough. The proprietary level system currently has file paths hard-coded in, which is not extensible at all. We had some difficulties with the Overlay API; first, I had to extend OverlayStat to change its color, and second, I wasn’t able to get the OverlayManager working properly so it was impossible to position each Overlay on the screen. This is why there is an OverlayStat for the player score but just a regular drawString() for the player lives. Finally, we need to make greater use of resources. Some of our int variables are constants, but nearly all of our Strings are not, which makes their modification more difficult than it should be. 

--GalaxyInvaders team

== Grandius ==

Possible ideas to consider:

-remove constructor in main Game class
-remove repetition in updateScreenSprites(): make SpriteGroup and int (number in the sprite list of the level) parameters instead.
-in updateEnemies(), split some of the for loops into separate methods. for the keyevents, make a method that calls in the SpriteGroup and a double to add to thespeed. that way it will take away the repetitive for-loops. have a different method for each arrow key.
-separate loadGrandiusLevel() into different methods
-BlackHole and Missile could extend ItemSprites, by using the act() method whenever they swallow enemies or make a hit and passing the max hits constants into the constructor.
-the game state control is implemented with an integer switch; seems like using the GameState API could simplify this

--GalaxyInvaders team

== Jumper ==


== Mario Clone ==


== Tower Defense ==
 

== Tron ==

Our game is called TRON in which multiple players try to kill each other by blocking the others’ path. The players can turn around and proceed like in the Snake game, except that they leave walls  behind them wherever they go. A player is dead whenever it hits the wall built by other players or itself, or when it hits the boundary of the game space. The players can either be controlled by human or by a computer.

Our design flow was to implement the game first and then port it to the VOOGA APIs. 
So right now it relies on GTGE to handle collision, player, resources and level. Our game makes use of the Collision Manager that GoldenT provides to handle the collisions, routinely update the player’s positions and determine the end of the game. Our game generates “random” levels with random-numbered, random-sized blocks. A new random level is generated whenever a level is finished (regardless of which player wins). Separate player objects are created for each player. The computer-controlled players implement the AI algorithms that controls their movement.

For the APIs in Vooga, the game only used the userInputEvent in event system to handle user input such as down, up ,right and left. The userInputEvent could be improved by allowing game developer to customize their keys. Using Overlay is also important because the game might allow player to choose whether it is one player or two player game. Since the game didn't use that much outside resouces such as pictures and sounds, it might not be necessary to use resources API.

Our next natural step would be to utilize more API’s to improve the succinctness and functionality of the game. Right now we are only using the event system, and we plan to at least make use of the player system, the level system and the collision manager. We will also improve our AI, probably creating different levels of AI for the computer-controlled player. We would also like to improve the graphics of the game. In the end, if we have time, we would implement a networked game where different human players can play from different computers vi networks. We would also need to add something like overlay or GUI in order for the player to choose game mode such as player vs PC and player vs player. 


--Meng Li,Brent Sodman,Jiaqi Yan Tron Game

== Zombieland ==

Overall the Zombieland game is nicely designed and it has pretty graphics and animations. However right now it is not using any of the API's. Therefore potentially it can integrate the game with more API's. Since this game already has a lot of pictures, it can put them in the resource manager. Also the level manager and player managers can be properly added. Another issue right now is that the zombies come towards the player in all directions, while the player can only shoot at straight up/down/left/right directions, which makes it very hard to actually shoot any zombies coming at the player. Hence it would be nice if the player could be able to turn around in any angle and shoot the zombies. 

--Meng Li,Brent Sodman,Jiaqi Yan

 