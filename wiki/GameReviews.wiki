#summary Discuss each Game in context of trying to create a coherent design.

= Introduction =

For each game listed below, your team should review its own game and the next game alphabetically. Your review should focus on how the game can be improved (or simplified) by using the VOOGA (or GTGE) APIs. The comments should generally be constructive in helping us to build a consensus API platform on which to build more complex games. Your review should include the entire game, not just the one class that extends Game.


== Cyberion ==

Our game, Cyberion, is a very simple and fun game in which you control a ship that tries to stay alive by either shooting the enemy ships down or simply avoiding the enemy ships and their "bullets".  There are bonuses you can recieve to increase your firepower to make it easier to shoot the enemy ships.

Our main method (other than update and render) in the main game class is initResources.  This method then calls various other methods which set sprites, collision detection, and event managers.  We created a collision group and manager for each possible collision using Golden T's built-in collision manager.

One thing we can improve on is making the code more dynamic.  For example, we hard-code each image file path.  In general, we have many sections with almost identical code, such as creating a collision manager for each collision type.  Another thing is using more of the Vooga API.  Right now we are only using the Event Manager API.

-Cyberion Team

== Doodle Jump ==

Overall we think we did a good job on our game, especially since it was only our first iteration.  The major things we have to fix are more labor intensive like writing longer, more comprehensive, accurate level files rather than serious faults with our code or logic behind the game.  The game graphically looks very good and we incorporated a lot of the iOS version of DoodleJump into our game in a short period of time.
	Code-wise, we could definitely use a little more of the class’ APIs but we also didn’t do that bad of a job in that respect initially.  We used the Player API extensively and we also made use of the Overlay and GameState APIs.  In our next iteration we could probably make use of the Resources API as well as maybe the Level API if they take our suggestions and look at the DoodleLevel class in our game and see how we can reconcile our two implementations of levels.  A lot of what determines how we use the APIs in the future is how much better the class make them.  We don’t think we neglected anything that would have made our game a lot better in any respect.  There’s also some code cleanup/commenting/documenting that we will do in our next version.
	Game-wise, the one thing we really need to do is make our level files much more robust.  The game at the end of the day is only as good as the levels we play in and right now they’re pretty short and basic.  The game will seem much, much better after we improve our levels.  While we do have some clear improvements we have to make for the next version, our initial version of Doodlejump we think was a success and shows the potential of the vooga game engine. -- (Doodle Jump)

We would review Doodle Jump very similarly to our game (Cyberion).  It is a good game with the same general principals of initialization and collision detection.  Also, just like ours, they need to worry about making the code more dynamic and removing repetitive code and method calls.  They did use more APIs than us, but could still probably incorporate more, especially once they are improved.

-Cyberion Team

== Galaxy Invaders ==

Our game, GalaxyInvaders, initially did not use many of the APIs from VOOGA, as we found it simpler (and faster) to implement their functionalities ourselves. We are going to change this in refactoring, and replace our custom-built Level class, for example, with an extension of the Levels API. The APIs we did use, however, we found to be quite useful, including the Player and Overlay groups’, which fit in with our game pretty well. Clearly, our next step is to replace our code with as much API code as possible, including using the Events API more extensively, and the Resources API to handle all of our images and possibly our level files.

One of the APIs we do not really envision a need for is the Collisions API, as collisions are handled automatically by the GTGE. We, along with most groups, implemented them directly via GoldenT and they worked quite well. While we understand that this API could in theory provide easier functionality, in its current state it seems to require even more code (such as extending Collidable) than the GTGE built-in detection.

Our code is still somewhat rough. The proprietary level system currently has file paths hard-coded in, which is not extensible at all. We had some difficulties with the Overlay API; first, I had to extend OverlayStat to change its color, and second, I wasn’t able to get the OverlayManager working properly so it was impossible to position each Overlay on the screen. This is why there is an OverlayStat for the player score but just a regular drawString() for the player lives. Finally, we need to make greater use of resources. Some of our int variables are constants, but nearly all of our Strings are not, which makes their modification more difficult than it should be. 

--GalaxyInvaders team

Can’t run game.  Even changing the input for level11.txt, etc. generates an error as those files are not in the vooga repository.  This group needs to add the proper resources correctly (level files, images, etc.) and then fix whatever hard coded file names they have in their code.  -- (DoodleJump)

== Grandius ==

Possible ideas to consider:

-remove constructor in main Game class

-remove repetition in updateScreenSprites(): make SpriteGroup and int (number in the sprite list of the level) parameters instead.

-in updateEnemies(), split some of the for loops into separate methods. for the keyevents, make a method that calls in the SpriteGroup and a double to add to thespeed. that way it will take away the repetitive for-loops. have a different method for each arrow key.

-separate loadGrandiusLevel() into different methods

-BlackHole and Missile could extend ItemSprites, by using the act() method whenever they swallow enemies or make a hit and passing the max hits constants into the constructor.

-the game state control is implemented with an integer switch; seems like using the GameState API could simplify this

--GalaxyInvaders team

The game itself is quite simple, though a little difficult to get used to in the beginning.  The movement of the screen relative to the player takes some getting used to, but other than that, it’s a pretty challenging, yet very playable game.  Also, the shopping round in between levels is a fun concept.
    The Collisions package in Grandius does not utilize the VOOGA collision API, and it also treats each combination of collision differently using different classes of collisions.  There’s a decent amount of repeated code within each of these collision classes, and though handling the various types of collisions is quite complex, perhaps the different collision classes could have been combined more efficiently.
    Grandius makes pretty good use of some of the other API’s available in VOOGA and even creates a custom Level class for Grandius (which almost makes the Level API’s value questionable).  It maybe could have used more of the tools in VOOGA since it only used 4 of the packages (Level, overlay, player, and resource).  The overall look and playability of the game is appealing and fun.
--Grandius team

== Jumper ==
The game play is pretty simple and easy to figure out.  Perhaps a short screen with instructions and game objectives at the beginning would be useful for those not familiar with this type of game.  But that’s not a huge issue since it’s quite simple, and it’s a pretty fun game.  However, the game can get pretty mindless and repetitive after about a minute of playing it.
    Jumper uses a few of the VOOGA API’s, but it follows the same trends as some other groups in choosing which API’s to actually use (such as resource and overlay).  It does create a JumperGameState class which is never used (or at least, it’s been commented out).
    There are some segments of repeated code.  For instance, the createNewBlocks() method in the main class has a huge if-tree with a lot of lines that look similar.  I think this could have been reduced by a lot.  As mentioned in class, a lot of the hard-coded String values, especially the repeated ones, could have been stored as private constant variables.
--Grandius team

== Mario Clone ==

When playing MarioClone, I was never really clear about the objective or progression of the game.  It seemed as if this was a cool idea for a game that never truly materialized.

In terms of the actual code, I am curious as to why this group used conventional Playfields for its “menu”, “end”, and “win” fields.  This seems like the perfect scenario for GameStates, because this would allow an easier—and cleaner—transition from state to state.  This change could cut down on a ton of repeated code, particularly in the initResources() method.  Also, this would eliminate the need for a “myGameState” variable as well as the “MAIN_MENU”, “GAME_PLAY”, “GAME_OVER”, and “GAME_WIN” constants, which all serve as messy constants that the State system was designed to eliminate.

I am not sure what the line “distribute = true” means.

All instance variables should consistently use (or not use) the “my” prefix.

It seems a bit sloppy/awkward to have a variable named “playfield” followed by the initialization of three Playfield objects. 

The MarioPlayField extension of PlayField does not seem to have any additional function beyond the loading of tiles.  It seems like this could just be done to a regular playfield in the main game’s update/render methods

I am unclear as to what a TileMap is, although perhaps this is just my own oversight (but some comments might have helped).

There are a bunch of hardcoded values in the render method that would mess everything up if the size of the board changed.

Some javadoc comments before methods and classes might have been helpful. 


== Tower Defense ==
 

== Tron ==

Our game is called TRON in which multiple players try to kill each other by blocking the others’ path. The players can turn around and proceed like in the Snake game, except that they leave walls  behind them wherever they go. A player is dead whenever it hits the wall built by other players or itself, or when it hits the boundary of the game space. The players can either be controlled by human or by a computer.

Our design flow was to implement the game first and then port it to the VOOGA APIs. 
So right now it relies on GTGE to handle collision, player, resources and level. Our game makes use of the Collision Manager that GoldenT provides to handle the collisions, routinely update the player’s positions and determine the end of the game. Our game generates “random” levels with random-numbered, random-sized blocks. A new random level is generated whenever a level is finished (regardless of which player wins). Separate player objects are created for each player. The computer-controlled players implement the AI algorithms that controls their movement.

For the APIs in Vooga, the game only used the userInputEvent in event system to handle user input such as down, up ,right and left. The userInputEvent could be improved by allowing game developer to customize their keys. Using Overlay is also important because the game might allow player to choose whether it is one player or two player game. Since the game didn't use that much outside resouces such as pictures and sounds, it might not be necessary to use resources API.

Our next natural step would be to utilize more API’s to improve the succinctness and functionality of the game. Right now we are only using the event system, and we plan to at least make use of the player system, the level system and the collision manager. We will also improve our AI, probably creating different levels of AI for the computer-controlled player. We would also like to improve the graphics of the game. In the end, if we have time, we would implement a networked game where different human players can play from different computers vi networks. We would also need to add something like overlay or GUI in order for the player to choose game mode such as player vs PC and player vs player. 


--Meng Li,Brent Sodman,Jiaqi Yan Tron Game

== Zombieland ==

Overall the Zombieland game is nicely designed and it has pretty graphics and animations. However right now it is not using any of the API's. Therefore potentially it can integrate the game with more API's. Since this game already has a lot of pictures, it can put them in the resource manager. Also the level manager and player managers can be properly added. Another issue right now is that the zombies come towards the player in all directions, while the player can only shoot at straight up/down/left/right directions, which makes it very hard to actually shoot any zombies coming at the player. Hence it would be nice if the player could be able to turn around in any angle and shoot the zombies. 

--Meng Li,Brent Sodman,Jiaqi Yan

 