#summary Discuss each API in context of trying to create a coherent design.

= Introduction =

For each API listed below, there should be nine reviews: one from each game team. As users of the API, should comment about its effectiveness, how it should be used, or if it should be merged with other APIs in an effort to build a consensus API that can be used to build more complex games. If your team did not use an specific API, try to explain your decision.


== Level ==
 * I do not think that a Level should be responsible for game state, resources, collisions, etc. I believe that is the role of the Game class. I think that the Level package should be responsible for traversing between the levels and initializing levels from files. I think that right now the initialization process should involve loading relevant images and sounds (through the Resources API) and initializing the Sprites and SpriteGroups to be passed back to the Game. In the future when a rules API is created, it could also pass relevant rules used to distinguish Gameplay between levels back to the game. --Daniel Koverman (Tower Defense)
 


== Player ==
 * The Control class and subclasses are effective at minimizing the effort required to set up a custom control scheme for a single player. The most general type of player control for a non networked game uses both the mouse and the keyboard so a MouseAndKeyboardControl class should be created which accepts input from both the mouse and keyboard to control the players. --Daniel Koverman (Tower Defense)

== States ==
 * States made it easy to create a main menu/pause/play/game over state and the fact that sprite groups can be shared between states was particularly convenient. I do not understand why GameState is an abstract class requiring an override of the initialize() method. Doodle created the DoodleState class which simply made initialize() an empty method and it would have been easier for them to use the GameState class. In Tower Defense, I create the State class which added new features to the GameState class but left initialize empty so I am unsure why the initialize() method requires an override. It would also be convenient for State to accept single Sprites in addition to Sprite groups because I don't think it will be very uncommon to have a game state such as a menu which is only a single sprite and it removes a little bit of the overhead in manually creating a sprite group which holds on sprite. States should also natively handle backgrounds because manually changing a Playfield to go along with game state changes is a pain. Though it was easy to create my own subclass to work with controls from the Player Control API, GameState or subclass in the state package should do this automatically as well in the interest of making things easier for the developer and better integrating the APIs. --Daniel Koverman (Tower Defense)

== Resources ==
 * The Resources class needs to be consistent where the path starts from loading images and from loading files. A way to specify a directory once and then load from there needs to be added. Sounds needs to work more similarly to images. The usefulness of GameClock is significantly reduced given that Golden T handles time between updates behind the scenes and the State API effectively handles pausing. Overall, the Resources class made it easier to load images than using the native Golden T image handling because images can now be loaded and used anywhere without requiring a pointed to an instance of Game. --Daniel Koverman (Tower Defense)

== Events ==
 - The Events API was not used by our team to handle events that occurred. One of the reasons we did not include the event listener was because at least for the main menu and the buying of the towers it was facilitated by the use of a key listener or a mouse listener and adding it to the event manager just increased the complexity without increasing the readability of the code. We could have used an Event manager to manage our win and loss conditions of the game, but the event manager had no control over the game itself which meant that in the end we would still have to change the game from the main game class and event listeners lose their functionality. If the Event manager were able to handle changes to the playfield, sprites or other elements of the game without actually having access to these elements or creating a new instance of these elements and passing it back, it could be more beneficial. I think that Event manager should be able to collaborate with Level and States API in order to give Event API more accessibility. Because as of now, Event manager can only handle if events occur, but are not able to implement any changes to the game without actually having the game being passed in as an argument. Especially looking at the EventListener class there is almost no functionality to it. True, it leaves things open ended for the user to implement, but unless Game Objects or Sprite Objects were created inside that class and returned back in the method there is no other way to affect changes in the game unless these are parameters passed in. -- Derek Zhou (Tower Defense) 

== Overlay ==

== Collisions ==
 * The Collisions API seems to have a lot of overhead to use (implementing Collidable for every object in question) without significantly reducing the amount of work required. Since we are are now dealing with Golden T and Sprites, I think CollisionManager or a subclass of CollisionManager inside the engine.collision package should work with Sprites automatically.  It also seems to me like the Collidable interface was created with the intention of creating a collision manager which would use the information Collidable requires to prevent the CollisionManager from having to loop through every possible Collidable object. Since this is not the case, Collidable seems unnecessary to me until such a CollisionManger is produced. I do not think that the Collisions API should be abandoned in deference to the collision managers in Golden T because those collision managers are built on the premise that they will be called every update and are a pain to set up if you only want to check for collisions occasionally (for instance making sure there is no overlap when placing a new Sprite in the game). --Daniel Koverman (Tower Defense)