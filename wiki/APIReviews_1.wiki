#summary Discuss each API in context of trying to create a coherent design.

= Introduction =

For each API listed below, there should be nine reviews: one from each game team. As users of the API, should comment about its effectiveness, how it should be used, or if it should be merged with other APIs in an effort to build a consensus API that can be used to build more complex games. If your team did not use an specific API, try to explain your decision.


== Level ==
 * I do not think that a Level should be responsible for game state, resources, collisions, etc. I believe that is the role of the Game class. I think that the Level package should be responsible for traversing between the levels and initializing levels from files. I think that right now the initialization process should involve loading relevant images and sounds (through the Resources API) and initializing the Sprites and SpriteGroups to be passed back to the Game. In the future when a rules API is created, it could also pass relevant rules used to distinguish Gameplay between levels back to the game. --Daniel Koverman (Tower Defense)
 


== Player ==
 * The Control class and subclasses are effective at minimizing the effort required to set up a custom control scheme for a single player. The most general type of player control for a non networked game uses both the mouse and the keyboard so a MouseAndKeyboardControl class should be created which accepts input from both the mouse and keyboard to control the players. --Daniel Koverman (Tower Defense)

== States ==
 * States made it easy to create a main menu/pause/play/game over state and the fact that sprite groups can be shared between states was particularly convenient. I do not understand why GameState is an abstract class requiring an override of the initialize() method. Doodle created the DoodleState class which simply made initialize() an empty method and it would have been easier for them to use the GameState class. In Tower Defense, I create the State class which added new features to the GameState class but left initialize empty so I am unsure why the initialize() method requires an override. It would also be convenient for State to accept single Sprites in addition to Sprite groups because I don't think it will be very uncommon to have a game state such as a menu which is only a single sprite and it removes a little bit of the overhead in manually creating a sprite group which holds on sprite. States should also natively handle backgrounds because manually changing a Playfield to go along with game state changes is a pain. Though it was easy to create my own subclass to work with controls from the Player Control API, GameState or subclass in the state package should do this automatically as well in the interest of making things easier for the developer and better integrating the APIs. --Daniel Koverman (Tower Defense)

== Resources ==
 * The Resources class needs to be consistent where the path starts from loading images and from loading files. A way to specify a directory once and then load from there needs to be added. Sounds needs to work more similarly to images. The usefulness of GameClock is significantly reduced given that Golden T handles time between updates behind the scenes and the State API effectively handles pausing. Overall, the Resources class made it easier to load images than using the native Golden T image handling because images can now be loaded and used anywhere without requiring a pointed to an instance of Game. --Daniel Koverman (Tower Defense)

== Events ==
 * The Events API was not used by our team to handle events that occurred. One of the reasons we did not include the event listener was because at least for the main menu and the buying of the towers it was facilitated by the use of a key listener or a mouse listener and adding it to the EventManager just increased the complexity without increasing the readability of the code. We could have used an EventManager to manage our win and loss conditions of the game, but the EventManager  had no control over the game itself which meant that in the end we would still have to change the game from the main game class and event listeners lose their functionality. If the EventManager were able to handle changes to the playfield, sprites or other elements of the game without actually having access to these elements or creating a new instance of these elements and passing it back, it could be more beneficial. I think that EventManager should be able to collaborate with Level and States API in order to give Event API more accessibility. Because as of now, EventListener can only handle if events occur, but are not able to implement any changes to the game without actually having the game being passed in as an argument. Especially looking at the EventListener class there is almost no functionality to it. True, it leaves things open ended for the user to implement, but unless Game Objects or Sprite Objects were created inside that class and returned back in the method there is no other way to affect changes in the game unless these are parameters passed in. --Derek Zhou (Tower Defense) 

  * We used part of the event system to develop our game. We used the UserInputEvent and UserInputEventAdapter to automatically handle user input such as key board. The API is easy to use while it has limited control of keyboard. For example, so far, it only handles mouse and 6 keys totally. So if the game developer wants to have more key options, he needs to write another UserInputEvent,which obviously is not a good idea. However, I think, the next step for input event system is to allow designer to set the customized key according to the action in the game. This would be a great improvement. (Tron Game, Meng Li)

== Overlay ==
 * The Overlay API greatly benefited our group. Our game used many OverlayString and OverlayStat. The methods were well designed and the classes were well thought out. There was no strenuous work on our end. We essentially just created a String with the text we wanted to display or an Int with the value we wanted to display and then created a new Overlay with that variable as a parameter. Then using the setLocation and setFont methods we placed it where we needed it and in what style we needed it. One thing that could be improved is development of a class that is specifically an overlay button where it has an event occur. This could be facilitated with an EventListener inside of the OverlayString class. I think that this would be a very beneficial class because many games incorporate buttons in some manner especially on the menu screen. --Derek Zhou (Tower Defense)

== Collisions ==
 * The Collisions API seems to have a lot of overhead to use (implementing Collidable for every object in question) without significantly reducing the amount of work required. Since we are are now dealing with Golden T and Sprites, I think CollisionManager or a subclass of CollisionManager inside the engine.collision package should work with Sprites automatically.  It also seems to me like the Collidable interface was created with the intention of creating a collision manager which would use the information Collidable requires to prevent the CollisionManager from having to loop through every possible Collidable object. Since this is not the case, Collidable seems unnecessary to me until such a CollisionManger is produced. I do not think that the Collisions API should be abandoned in deference to the collision managers in Golden T because those collision managers are built on the premise that they will be called every update and are a pain to set up if you only want to check for collisions occasionally (for instance making sure there is no overlap when placing a new Sprite in the game). --Daniel Koverman (Tower Defense)

 * Our team used Golden T’s collision API because VOOGA’s collision API doesn’t help ease our developing process. From my perspective, Golden T’s collision API handles collisions well. It offers all basic methods needed at least for our game. The VOOGA’s collision API offers collides(Collidable object1, java.util.List<Collidable> listOfObjects), which is nice because I need to build a player group in order to use Golden T’s collision API. Another question about collision is that until now, all our collisions are based on sprite images. I mean a collision is detected when the boarders of images collide. Can we detect collision based on sprites’ actual shape? It would be really useful if our collision API supports that. 