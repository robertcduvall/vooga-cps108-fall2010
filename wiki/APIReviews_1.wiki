#summary Discuss each API in context of trying to create a coherent design.

= Introduction =

For each API listed below, there should be nine reviews: one from each game team. As users of the API, should comment about its effectiveness, how it should be used, or if it should be merged with other APIs in an effort to build a consensus API that can be used to build more complex games. If your team did not use an specific API, try to explain your decision.


== Level ==
 * I do not think that a Level should be responsible for game state, resources, collisions, etc. I believe that is the role of the Game class. I think that the Level package should be responsible for traversing between the levels and initializing levels from files. I think that right now the initialization process should involve loading relevant images and sounds (through the Resources API) and initializing the Sprites and SpriteGroups to be passed back to the Game. In the future when a rules API is created, it could also pass relevant rules used to distinguish Gameplay between levels back to the game. --Daniel Koverman (Tower Defense)

  * I agree with Daniel about the collisions and game states being independent of the Levels system. However, it is hard for us to examine the API thoroughly as our game did not involve multiple levels and so the use of the API was unnecessary. (Cody Kolodziejzyk, Jumper) 

  * Although the Level API has many useful methods, the format didn’t seem to benefit the level system required by our game, leading us to create our own (which implemented some of the functionality of the VOOGA Level).  Since each of our levels needs a different speed and path for the enemy sprites, we would have to override loadLevel() to read and take in coordinates for the path instead of each sprite’s initial location.
In our refactoring, we plan to create a new class that extends Level and then overrides loadLevel(), so we can avoid the duplicate code in our game from the API. --GalaxyInvaders team


== Player ==
 * The Control class and subclasses are effective at minimizing the effort required to set up a custom control scheme for a single player. The most general type of player control for a non networked game uses both the mouse and the keyboard so a MouseAndKeyboardControl class should be created which accepts input from both the mouse and keyboard to control the players. --Daniel Koverman (Tower Defense)

 * This API was developed well.  I like how playerSprite extends gameEntitySprite and gameEntitySprite extends GTGE's sprite class.  Being able to utilize the GTGE's sprite class is greatly helpful.  We were able to do everything we need to with out player sprite with this API.  --Devon (Jumper)

 * gameEntitySprite might be redundant. It extends GTGE’s Sprite class, however, does not offer more methods differentiate it from Sprite class. Player class helps facilitate game design. I’m not sure how control classes in it work. We used GTGE’s base input class to control player, and I think it is convenient. --Hao He (Cyberion)

  * We found the Player API helpful and easy to use, but we did not implement the keyboard control through the Control class. It was simpler to just access the keyDown() and keyPress() methods directly from Golden-T, although in our refactoring we will likely try to change this to implement the custom control scheme. (Hao, by the way, the one key feature we were going for in GameEntitySprite was multiple-sprite representation of a single player/item/etc) --GalaxyInvader team

== States ==
 * States made it easy to create a main menu/pause/play/game over state and the fact that sprite groups can be shared between states was particularly convenient. I do not understand why GameState is an abstract class requiring an override of the initialize() method. Doodle created the DoodleState class which simply made initialize() an empty method and it would have been easier for them to use the GameState class. In Tower Defense, I create the State class which added new features to the GameState class but left initialize empty so I am unsure why the initialize() method requires an override. It would also be convenient for State to accept single Sprites in addition to Sprite groups because I don't think it will be very uncommon to have a game state such as a menu which is only a single sprite and it removes a little bit of the overhead in manually creating a sprite group which holds on sprite. States should also natively handle backgrounds because manually changing a Playfield to go along with game state changes is a pain. Though it was easy to create my own subclass to work with controls from the Player Control API, GameState or subclass in the state package should do this automatically as well in the interest of making things easier for the developer and better integrating the APIs. --Daniel Koverman (Tower Defense)

 * I tried using States to make a temporary powerup state for my player in which his image changes and his speed increases.  I found that the player rendered only sporadically and ended up creating the powerup state a different way; I don't know if this is an issue with state or something else that I'm missing.  It would also be helpful if there was a way to make a temporary state.  For instance, have method that activates the state for 15 seconds and then reverts to the previous state. --Devon (Jumper)

  * We used an integer to toggle between game states, where we now realize we could have used the States API to do the same things. It appears to be quite an elegant structure and would make our game much more extensible. It will be implemented in refactoring.  --GalaxyInvader team

== Resources ==
 * The Resources class needs to be consistent where the path starts from loading images and from loading files. A way to specify a directory once and then load from there needs to be added. Sounds needs to work more similarly to images. The usefulness of GameClock is significantly reduced given that Golden T handles time between updates behind the scenes and the State API effectively handles pausing. Overall, the Resources class made it easier to load images than using the native Golden T image handling because images can now be loaded and used anywhere without requiring a pointed to an instance of Game. --Daniel Koverman (Tower Defense)

 * Daniel already mentioned this, but my only annoyance was that the sound and image handlers are different.  No real issues with the API though, did what I needed it to do.  --Devon (Jumper)

 * We didn’t use resource API because Daniel told me that they were going to refine it last Wednesday. I just looked at their game. It seems good because we can reuse all the resources. My suggestion would be reading from a .txt file and load all the necessary resources automatically. I also have problem playing their game, might be some issues related to path. We can use System.getProperty("user.dir") to get user’s current working directory so that user only needs to input relative path. --Hao He (Cyberion)

  * We used the randomizer from the Resources API and had success with it. While we hardcoded our levels into files and loaded images directly, we intend to implement image handling with the Resources package in our refactoring. --GalaxyInvaders

== Events ==
 * The Events API was not used by our team to handle events that occurred. One of the reasons we did not include the event listener was because at least for the main menu and the buying of the towers it was facilitated by the use of a key listener or a mouse listener and adding it to the EventManager just increased the complexity without increasing the readability of the code. We could have used an EventManager to manage our win and loss conditions of the game, but the EventManager  had no control over the game itself which meant that in the end we would still have to change the game from the main game class and event listeners lose their functionality. If the EventManager were able to handle changes to the playfield, sprites or other elements of the game without actually having access to these elements or creating a new instance of these elements and passing it back, it could be more beneficial. I think that EventManager should be able to collaborate with Level and States API in order to give Event API more accessibility. Because as of now, EventListener can only handle if events occur, but are not able to implement any changes to the game without actually having the game being passed in as an argument. Especially looking at the EventListener class there is almost no functionality to it. True, it leaves things open ended for the user to implement, but unless Game Objects or Sprite Objects were created inside that class and returned back in the method there is no other way to affect changes in the game unless these are parameters passed in. --Derek Zhou (Tower Defense) 

  * We used part of the event system to develop our game. We used the UserInputEvent and UserInputEventAdapter to automatically handle user input such as key board. The API is easy to use while it has limited control of keyboard. For example, so far, it only handles mouse and 6 keys totally. So if the game developer wants to have more key options, he needs to write another UserInputEvent,which obviously is not a good idea. However, I think, the next step for input event system is to allow designer to set the customized key according to the action in the game. This would be a great improvement. (Tron Game, Meng Li)

  * Our team did not use the Events API mostly because the number and type of events included in our game did not necessarily constitute the use of the package. The Events API is designed based on listeners that respond when an object fires an event. Since the events in our game were the player simply colliding with blocks, the listener design is not exactly necessary. We also used the built in keyboard response in GoldenT to deal with key presses. (Cody Kolodziejzyk, Jumper)

 * Our event system is not designed to handle user input because it’s easy to do that using Java implemented listener. Golden T also provides base input API to do that. Our event system is designed to build tunnels between objects in a game so that they can keep their independency while be able to communicate with each other. We used lots of event API in our game (Cyberion), and I believe it is useful. Please refer to our example at Vooga/examples/event or our game at Vooga/games/cyberion. --Hao He (Cyberion)

  * Although we found the Events API to be quite elegant, we did not see an immediate need for it in our game. As such, we chose to not implement it, but having seen examples of its implementation we may try to include it in our refactoring. --GalaxyInvaders team

== Overlay ==
 * The Overlay API greatly benefited our group. Our game used many OverlayString and OverlayStat. The methods were well designed and the classes were well thought out. There was no strenuous work on our end. We essentially just created a String with the text we wanted to display or an Int with the value we wanted to display and then created a new Overlay with that variable as a parameter. Then using the setLocation and setFont methods we placed it where we needed it and in what style we needed it. One thing that could be improved is development of a class that is specifically an overlay button where it has an event occur. This could be facilitated with an EventListener inside of the OverlayString class. I think that this would be a very beneficial class because many games incorporate buttons in some manner especially on the menu screen. --Derek Zhou (Tower Defense)

 * Agreed.  This API is generally simple and worked for our group to use the score counter.  No issues here.  --Devon (Jumper)

  * We found the Overlay API very useful -- however, it seems to be competing with Player with regards to stat tracking. It makes more sense to keep track of stats as Stat<Int> variables separate from the Player class as of right now, since they have to be of this type to be used by the Overlay package. I assume that we wrote our code incorrectly.
Another issue we ran into using this API was the ability to change the color of the text in the OverlayStat class. While you can easily do this in OverlayString, it seemed like we had to extend OverlayStat to do the same.  --GalaxyInvaders

== Collisions ==
 * The Collisions API seems to have a lot of overhead to use (implementing Collidable for every object in question) without significantly reducing the amount of work required. Since we are are now dealing with Golden T and Sprites, I think CollisionManager or a subclass of CollisionManager inside the engine.collision package should work with Sprites automatically.  It also seems to me like the Collidable interface was created with the intention of creating a collision manager which would use the information Collidable requires to prevent the CollisionManager from having to loop through every possible Collidable object. Since this is not the case, Collidable seems unnecessary to me until such a CollisionManger is produced. I do not think that the Collisions API should be abandoned in deference to the collision managers in Golden T because those collision managers are built on the premise that they will be called every update and are a pain to set up if you only want to check for collisions occasionally (for instance making sure there is no overlap when placing a new Sprite in the game). --Daniel Koverman (Tower Defense)

 * Our team used Golden T’s collision API because VOOGA’s collision API doesn’t help ease our developing process. From my perspective, Golden T’s collision API handles collisions well. It offers all basic methods needed at least for our game. The VOOGA’s collision API offers collides(object1, java.util.List listOfObjects), which is nice because I need to build a player group in order to use Golden T’s collision API. Another question about collision is that until now, all our collisions are based on sprite images. I mean a collision is detected when the boarders of images collide. Can we detect collision based on sprites’ actual shape? It would be really useful if our collision API supports that. --Hao He (Cyberion) 

  * Golden T's collision system was extremely useful to us when we were developing Jumper. Since each collision results in a different reaction depending on the type of block, we simply assigned each type of block a separate ID number and then specified each result in the DoodleToBlockCollision class based on that number. This seemed simple enough and so we did not end up using VOOGA's collision API. (Cody Kolodziejzyk, Jumper)

  * Since GoldenT has its own CollisionManager, we found the VOOGA one to be slightly redundant, and requiring of a lot more overhead code, such as implementing Collidable. We think that for the class to use this API instead of the built in GTGE collision system, it should provide some functionality beyond what GoldenT does, but we’re not sure what that would be. --GalaxyInvaders team