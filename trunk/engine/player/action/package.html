<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
</head>
<body bgcolor="white">
<p>

The package is basically two enhancements to the ways Greenfoot (and most game engines in general) reperesent participants in a game.
<br />
<br />
First, we created a Player that acts as an extension of Greenfoot's actor class. It inherits all of the convenience methods of the Actor class (rotating, setting location, act method called each iteration of the run loop, etc.), but we also added state that most players in a game share like lives, score, item cache, etc.  This makes it much more convenient for the programmer to record and access these common attributes.  We also made an Item class which is basically a way for the programmer to create power-ups, weapons, etc. that appear in the world that a Player can pick up and possibly use.  If the programmer uses the Item class, there are methods built in to our Player/Item classes that make it easy for the Player to store items and use them when they want to.
<br />
<br />
The other main part of our API is the Control class, which accepts a variety of options for an input (eg. keyboard, mouse, AI, network) and calls some predetermined action based on when events occur within that input. The Control class takes one or more players to call these actions on.  This way a Player can easily take input from multiple sources (eg. keyboard and network) while we also abstract the actual detection and callbacks of events from the programmer.  This class takes advantage of Java's Reflection logic to register a method to be called on a certain class whenever an event of the programmer's choice occurs.
<br />
<br />
The Control, Player, and Item classes will be closed from modification, so programmers will have to extend them to take advantage of them.  If the programmer wants to modify the Player or Item classes, all they have to do is extend it and add any behavior or state they want.  When extending Player and Item, the programmer needs to make sure to use one of the provider constructors to initialize the correct instance variables or just do it manually.  Extending Control is a bit more complicated but still pretty easy.  When the programmer extends Control, they are adding a new input device to be used by Control.  To get the desired functionality, the programmer has to override the addInput method and define the input and actions and save it into a map.  Then they have to override the act method to check if any events saved in the map have occurred and then call the corresponding actions.  Assuming the programmer wants to keep the keyboard and mouse functionality, they should call the super class's addInput and act methods at the top of their own.
<br />
<br />
One thing we went back and forth on was making Item extend Actor instead of Player.  We eventually made the decision to have it extend Actor because that logically makes the most sense. Extending Player would repeat less code, but it doesn't fit as well logically so we decided to have it extend Actor.
<!-- Put @see and @since tags down here. -->

</body>
</html>
