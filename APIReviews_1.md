# Introduction #

For each API listed below, there should be nine reviews: one from each game team. As users of the API, should comment about its effectiveness, how it should be used, or if it should be merged with other APIs in an effort to build a consensus API that can be used to build more complex games. If your team did not use an specific API, try to explain your decision.


## Level ##
  * I do not think that a Level should be responsible for game state, resources, collisions, etc. I believe that is the role of the Game class. I think that the Level package should be responsible for traversing between the levels and initializing levels from files. I think that right now the initialization process should involve loading relevant images and sounds (through the Resources API) and initializing the Sprites and SpriteGroups to be passed back to the Game. In the future when a rules API is created, it could also pass relevant rules used to distinguish Gameplay between levels back to the game. --Daniel Koverman (Tower Defense)

  * I agree with Daniel about the collisions and game states being independent of the Levels system. However, it is hard for us to examine the API thoroughly as our game did not involve multiple levels and so the use of the API was unnecessary. (Cody Kolodziejzyk, Jumper)

  * Although the Level API has many useful methods, the format didn’t seem to benefit the level system required by our game, leading us to create our own (which implemented some of the functionality of the VOOGA Level).  Since each of our levels needs a different speed and path for the enemy sprites, we would have to override loadLevel() to read and take in coordinates for the path instead of each sprite’s initial location. In our refactoring, we plan to create a new class that extends Level and then overrides loadLevel(), so we can avoid the duplicate code in our game from the API. --GalaxyInvaders team

  * I agree with Daniel. I think that the level system should be responsible for initializing level settings from rules file. It should also be able to collaborate with resource system to let them know which files are necessary for the current level. Our team also had hard time using level system to initialize enemy sprites’ movements, and ended up initializing them at random locations and moving down at a steady speed. --Hao He (Cyberion)

  * The Level API and the GameState API are currently fighting for control of some of the same things in the game engine. The GameState API seems to take the level as simply a description of the layout of the level, but the level API seems to be acting to manage the rules/collisions/etc that could be handled by specific APIs and then passed to the controlling GameState. The level API in its current state wasn't extremely useful, leading us to procedurally create levels instead of storing any level data. (Tron)

  * While we included levels as part of our game, we didn’t actually use the Level API.  While our implementation was similar, the Level API wasn’t flexible enough to allow much differentiation in the way the file is read.  For example, we wanted the first line to be the image that will be the background of the screen and the last line to be the score the user needs to reach to make the next level and then the number of the next level.  The Level API’s insistence on reading everything as an image, location, and velocity (which also was kind of overkill since most of the objects in our game didn’t need a velocity) made it impossible to implement this sort of functionality. These issues can mostly be resolved if we as a class decide to take background stuff and logic about navigating between levels out of the level files.  However, the one thing that really hampered us from using the Level API was it using Sprites and Animated Sprites instead of our own GameEntitySprite extensions.  For example, when we read in a white platform we want it to create a WhitePlatform object not a Sprite.  This occurred for almost every part of our game and made using the Level API simply not a good decision. --Adam Cue (DoodleJump)

  * We agree with Daniel K - we think the Level package should be, possibly among other things, responsible for loading levels from files. A decision must be made as to what sorts of level files can be accepted - their formatting, data, etc. --Grandius team

  * We did not use the vooga level system because it’s designed to make creating a number of sprites with predefined location information from a level file very easy. We simply did not see the benefit for utilizing such a system because our levels involved spawning a number of zombies and possibly modifying the properties of the zombies being spawned for each level. The level system in vooga right now is very specific and does not provide a flexible way for processing the information received from a formatted file. It creates a sprite with an image and locations and does not provide any support for creating different types of objects and adding information other than the locations. (Zombieland)

  * My conception of a level is as something of a substate of a game state.  A developer would use game states at very highest level, where entirely different game behaviors are in play.  For instance, a main menu screen should behave entirely differently from the gameplay itself.  On the other hand, a level contains only resources, sprites, etc. that differ from other levels.  Every level within a game state should expect the same behavior to be carried out in the game loop.

> As others have said, a good way to enable this different behavior is to allow files containing level configurations to be imported.  This would lend us flexibility that is not afforded by the current VOOGA level API.  So far, our game is not making use of the level API, but we will explore it in the next several days.  We are using a TileMap class to create a map that is composed of a number of tiles.  This TileMap, a set of enemy sprites, and a background image are essentially the only thing that will differ from level to level, so it would not be very difficult in our case to simply create our own level as a container for these resources.   --David Herzka (MarioClone)

## Player ##

  * The Control class and subclasses are effective at minimizing the effort required to set up a custom control scheme for a single player. The most general type of player control for a non networked game uses both the mouse and the keyboard so a MouseAndKeyboardControl class should be created which accepts input from both the mouse and keyboard to control the players. --Daniel Koverman (Tower Defense)

  * This API was developed well.  I like how playerSprite extends gameEntitySprite and gameEntitySprite extends GTGE's sprite class.  Being able to utilize the GTGE's sprite class is greatly helpful.  We were able to do everything we need to with out player sprite with this API.  --Devon (Jumper)

  * gameEntitySprite might be redundant. It extends GTGE’s Sprite class, however, does not offer more methods differentiate it from Sprite class. Player class helps facilitate game design. I’m not sure how control classes in it work. We used GTGE’s base input class to control player, and I think it is convenient. --Hao He (Cyberion)

  * We found the Player API helpful and easy to use, but we did not implement the keyboard control through the Control class. It was simpler to just access the keyDown() and keyPress() methods directly from Golden-T, although in our refactoring we will likely try to change this to implement the custom control scheme. (Hao, by the way, the one key feature we were going for in GameEntitySprite was multiple-sprite representation of a single player/item/etc) --GalaxyInvader team

  * While we did not directly use the Player class to its fullest, its one of the things I look forward to using when we refactor. The entity/player hierarchy seems strange, but the class itself looks very useful. Everything else has been said above. (Tron)

  * We used PlayerSprite to represent our Doodle and Control to take input and make him act accordingly,.  This API actually ended up helping our game a lot since GoldenT didn’t really have anything like this before.  The PlayerSprite class let us easily keep track of his score while also letting us change his appearance based on certain conditions (moving left, moving right, shooting, etc.)  Control was an effective way of taking input from the keyboard and making Doodle move left or right and shoot.  We didn’t have to worry about a whole lot except for setting the left arrow to call the moveLeft() method on DoodleSprite, our extension of PlayerSprite. The only thing that was a little confusing at first was having PlayerSprite extend Sprite but also have a Sprite instance field.  However once we started using PlayerSprite it made sense to have this style since we wanted the behavior of a Sprite but we also wanted to be able to change Sprites that represent our player.  This group made the right decision, but if it was documented a little better it would have been perfect. --Adam Cue (DoodleJump)

  * There is some overlap with overlay in that Player keeps track of some values that could be taken care of and displayed by an overlay.  Or, if the Player class kept these values, perhaps they could store it as one of the overlay class’s Stat 

&lt;Integer&gt;

 values, and pass that as a parameter to overlay. --Grandius team

  * The PlayerSprite class and the more general GameEntitySprite classes are very helpful in setting up the foundations of the game mechanics. They made it especially easy for us to add the different animations to the zombie and the shooter at different states. The mapToSprite and setCurrentSprite methods allowed for each player/zombie object to be associated with different animatedSprites that hold the different animation states for each object and all we had to do was to switch between the animations to correspond to the actions of the object. (Zombieland)

  * The keyboard control class was also very effective. It allowed us to simply assign different keys to specific actions for the player without having to deal with the events or passing information through to different classes. We simply needed to write specific actions for the objects and map keys to those actions and everything works smoothly. However, there’s one thing that we would like to do but was unable to accomplish since we were not allowed to make major changes to the APIs. We wanted the keyboard controller to be able to process multiple key presses at the same time, allowing for actions such as shooting and switching while moving. This would make the game much better in the actual game play (Zombieland)

  * We found the Player class to be well executed and pretty easy to use. We used both the PlayerSprite and KeyControl classes for the basic mechanics of our game, which made getting started pretty easy.  The handling of multiple sprites for a player works particularly well. I agree with the team above that multiple key inputs would be very helpful.-Andrew (MarioClone)

## States ##
  * States made it easy to create a main menu/pause/play/game over state and the fact that sprite groups can be shared between states was particularly convenient. I do not understand why GameState is an abstract class requiring an override of the initialize() method. Doodle created the DoodleState class which simply made initialize() an empty method and it would have been easier for them to use the GameState class. In Tower Defense, I create the State class which added new features to the GameState class but left initialize empty so I am unsure why the initialize() method requires an override. It would also be convenient for State to accept single Sprites in addition to Sprite groups because I don't think it will be very uncommon to have a game state such as a menu which is only a single sprite and it removes a little bit of the overhead in manually creating a sprite group which holds on sprite. States should also natively handle backgrounds because manually changing a Playfield to go along with game state changes is a pain. Though it was easy to create my own subclass to work with controls from the Player Control API, GameState or subclass in the state package should do this automatically as well in the interest of making things easier for the developer and better integrating the APIs. --Daniel Koverman (Tower Defense)

  * I tried using States to make a temporary powerup state for my player in which his image changes and his speed increases.  I found that the player rendered only sporadically and ended up creating the powerup state a different way; I don't know if this is an issue with state or something else that I'm missing.  It would also be helpful if there was a way to make a temporary state.  For instance, have method that activates the state for 15 seconds and then reverts to the previous state. --Devon (Jumper)

  * We used an integer to toggle between game states, where we now realize we could have used the States API to do the same things. It appears to be quite an elegant structure and would make our game much more extensible. It will be implemented in refactoring.  --GalaxyInvader team

  * The reason why GameState is an abstract class is so that you can initialize all of the state's  sprites within the class so that you have better control of what you have on each state. Having said that, I could not get the initialization to work inside the GameState, which rendered the entire purpose of initialize() useless. Another problem that I have is that many times sprites are players and players require baseInputs in order to answer to events; GameStates could not manage to take bsInputs so that player sprites could not be used.In addition, have in mind that GameStates expect you to do all of your updating and rendering using GameManager. This means you must always use GameStates for all your possible GameStates. This is probably the reason why it didn't work for people who wanted to do one GameState separate from the normal stream of the game. As of now I still think GameState as a concept is a powerful tool that will simplify the process of creating games, but there are two things that need to be addressed:  resource initialization and input support. – Vitor Olivier(Cyberion)

  * The two problems I think that people are having with GameStates are (1) that we weren't clear enough in describing what the GameState class is for and (2) that GameState needs to be updated to manage Sprites correctly (as a playfield instead of a Collection Sprite). GameState is to be used as a high-level container class (containing the level data, etc, much like a playfield would) that can then be swapped out statically or dynamically to create Pause states or Menu states. It should not be used for in-level mechanics like power-ups, etc. (Tron)

  * As a group, we tried to utilize the gamestates in order to make a pause screen, menu, and gameplay state.  However, the API was a little confusing as well as difficult to implement.  We started programming the basics of the game and the menu system was one of our last concerns.  By the time we we able ready to incorporate the gamestates into our design, a bulk of the coding had been done.  It would have been too time consuming in order to add all of the sprites to their respective game states and thus we instead opted for a simple menu counter which used specific keyboard inputs in order to start and pause the game. The game states would have been a great feature to use in our design and we will hopefully implement this API in our future revision.  Some aspects of the API we were confused about, as a lot of the coding of the API had been commented out or were very basic features, such as adding to a game state or switching.  We also ran into problems with displaying the menus free of sprites - such as the start screen and the pause menu.  During both, the whole game can be seen and the background remains in the background.  One solution might be to render the background image as a sprite itself and have that be the only sprite rendered during the start/pause screen but it was too time consuming to implement before we finished the core of the game. -- Nick Straub (DoodleJump)

  * Commenting on Trons description of states, we had problems due to the face that the sprites were separated from the sprite groups that we passed in.  When the game was restarted from the restart screen, even though the sprites were deleted from the sprite group they were assigned to, they were still on the board since the sprites were also in the collection in the State groups class.  To solve this we just deleted the whole state, and added an entirely new state. -- Justin Goldsmith (Tower Defense)

  * The Zombieland group did not use the state system in the game. The only state that we did employ was the gameOver state, which utilizes the game method pause() provided by GoldenT rather than the abstract state system . (Zombieland)

  * For MarioClone, we did not utilize the GameState API.  Instead, we hard-coded different items to render and behaviors to perform in each state in the render() and update() in the game core class, MarioClone.  For this Sunday, we plan to use the API to separate game states and organize the game more effectively.  -- David Herzka (MarioClone)

> Hats off to the GameState crew for including well written, easy to follow JavaDoc comments to help interpret how their API functions. Unfortunately, I did not end up using the actual GameState  API as part of our code because we found that we could simply use instance variable integer constants to represent our different states, which let us use a marginal amount of code and not having to worry about creating multiple GameState objects. As we discussed in class on Wednesday, I think the GameState API would be much stronger if its methods centered on PlayFields as opposed to SpriteGroups. In our game, the PlayField was a very powerful object that could on its on represent an entire state. If the GameState API was tweaked to incorporate constructing GameStates based on PlayFields, I think it would be a much more useful tool. –Cameron (MarioClone)

## Resources ##
  * The Resources class needs to be consistent where the path starts from loading images and from loading files. A way to specify a directory once and then load from there needs to be added. Sounds needs to work more similarly to images. The usefulness of GameClock is significantly reduced given that Golden T handles time between updates behind the scenes and the State API effectively handles pausing. Overall, the Resources class made it easier to load images than using the native Golden T image handling because images can now be loaded and used anywhere without requiring a pointed to an instance of Game. --Daniel Koverman (Tower Defense)

  * Daniel already mentioned this, but my only annoyance was that the sound and image handlers are different.  No real issues with the API though, did what I needed it to do.  --Devon (Jumper)

  * We didn’t use resource API because Daniel told me that they were going to refine it last Wednesday. I just looked at their game. It seems good because we can reuse all the resources. My suggestion would be reading from a .txt file and load all the necessary resources automatically. I also have problem playing their game, might be some issues related to path. We can use System.getProperty("user.dir") to get user’s current working directory so that user only needs to input relative path. --Hao He (Cyberion)

  * We used the randomizer from the Resources API and had success with it. While we hardcoded our levels into files and loaded images directly, we intend to implement image handling with the Resources package in our refactoring. --GalaxyInvaders

  * I couldn't get the Resource loader to initialize from a text file correctly and eventually gave up. It will be the first thing we tackle when we refactor our code, because I think it has been majorly changed from when I tried to use it. (Tron)

  * The DoodleJump group did not use resources in our game.  The resource aspects built in to GoldenT, like the getImage method in the Game class, proved to suffice for our basic needs like loading an image for a Sprite.  The only things that were not as clean, such as loading an image from within our Doodle Sprite class since that didn’t have the getImage method, were not handled by the Resources API.
> There is a lot of interesting things in this API like the high score handler, data handler, and clock features, but we didn’t really have time to make use of these while also trying to make the core of our game.  The only thing we would’ve used (loading images, sounds, files, etc.) wasn’t worth using.  We’ll definitely look into using some of the Resources API in the next version of our game.  -- Adam Cue (DoodleJump)

  * The image loading was very easy to use and was very helpful. However, there should probably be a better way to load all the images. For our game, we needed to load many different images as the animations relied on multiple images to be looped through to created the moving image. The game resources manager should allow for loading large images dynamically. For example, it would be nice to define all the variables that hold the loaded images and have the resources manager look for the image files corresponding to each variable (i.e. having the same name/prefix) and load them automatically. For all the variables that are defined as being animated, the resources manager would try to find as many images as possible corresponding to the variable name and initialize them as an animated sprite, which requires extra code to initialize the animation, set the delay, and determine whether the animation is looped or not. (Zombieland)

  * We used the Resource package’s image handling capabilities extensively. This package’s HighScoreHandler would be an interesting feature to use when designing the Arcade game. We also want to explore the possibility of randomness in our game, and have yet to explore the functionality of Randomizer fully. In terms of improvements to the Resources package, we agree that the sounds and images should be handled similarly to avoid confusion. --Grandius team

  * The Resource API was very effective for organizing our in-game images.  A resource file containing keys and file paths for images was created rather than hardcoding paths.  Within the code, we just had to call Resource.getImage(String key) to import the appropriate image.  This will surely make it very easy to continue adding more sprites and other images to the game as well as sounds and animations. --David Herzka (MarioClone)

## Events ##
  * The Events API was not used by our team to handle events that occurred. One of the reasons we did not include the event listener was because at least for the main menu and the buying of the towers it was facilitated by the use of a key listener or a mouse listener and adding it to the EventManager just increased the complexity without increasing the readability of the code. We could have used an EventManager to manage our win and loss conditions of the game, but the EventManager  had no control over the game itself which meant that in the end we would still have to change the game from the main game class and event listeners lose their functionality. If the EventManager were able to handle changes to the playfield, sprites or other elements of the game without actually having access to these elements or creating a new instance of these elements and passing it back, it could be more beneficial. I think that EventManager should be able to collaborate with Level and States API in order to give Event API more accessibility. Because as of now, EventListener can only handle if events occur, but are not able to implement any changes to the game without actually having the game being passed in as an argument. Especially looking at the EventListener class there is almost no functionality to it. True, it leaves things open ended for the user to implement, but unless Game Objects or Sprite Objects were created inside that class and returned back in the method there is no other way to affect changes in the game unless these are parameters passed in. --Derek Zhou (Tower Defense)

  * We used part of the event system to develop our game. We used the UserInputEvent and UserInputEventAdapter to automatically handle user input such as key board. The API is easy to use while it has limited control of keyboard. For example, so far, it only handles mouse and 6 keys totally. So if the game developer wants to have more key options, he needs to write another UserInputEvent,which obviously is not a good idea. However, I think, the next step for input event system is to allow designer to set the customized key according to the action in the game. This would be a great improvement. (Tron Game, Meng Li)

  * Our team did not use the Events API mostly because the number and type of events included in our game did not necessarily constitute the use of the package. The Events API is designed based on listeners that respond when an object fires an event. Since the events in our game were the player simply colliding with blocks, the listener design is not exactly necessary. We also used the built in keyboard response in GoldenT to deal with key presses. (Cody Kolodziejzyk, Jumper)

  * Our event system is not designed to handle user input because it’s easy to do that using Java implemented listener. Golden T also provides base input API to do that. Our event system is designed to build tunnels between objects in a game so that they can keep their independency while be able to communicate with each other. We used lots of event API in our game (Cyberion), and I believe it is useful. Please refer to our example at Vooga/examples/event or our game at Vooga/games/cyberion. --Hao He (Cyberion)

  * Although we found the Events API to be quite elegant, we did not see an immediate need for it in our game. As such, we chose to not implement it, but having seen examples of its implementation we may try to include it in our refactoring. --GalaxyInvaders team

  * Events were not used in Doodle Game. The provided events were basic controls which were more easily instantiated using the Player Control class. It seems as if there is confusion about what an Event really is supposed to be. Something like user input should not be tied to an event, this is input and can be handled using the controls class. An event should be specific to game play, such as something that is triggered over time, or something that occurs after an action or set of actions. It looks like event is open to these things, but as of now it doesn’t look like there is an easy way to implement them. -- Marcus Molchany (DoodleJump)

  * We did not use the vooga event maanger class. For us, events were primarily keyboard events and collision events. We did not have any other special events currently, but certainly, we would like to use event manager to help us design a game menu, a pause screen, a game restart operation, or a help screen. Events should include game states because most of the operations on game states (i.e. displaying a help screen or the main menu) are directly related to interruption in gameplay and switching to a different GUI. Certainly, the interaction between game state and events is something that needs to be done at some point.  (Zombieland)

  * We will look into this API in terms of handling our keyboard input events and our mouse clicks (on menus). We believe this API should be able to help us reduce the amount of code in our main game class, because right now it includes a good amount of repeated code in terms of handling key presses to fire weapons, as well as selecting menu options. --Grandius team

  * Our team did not use the Events API. The only events in our game were associated with Player controls, which we used from the Player API, and collisions, for which we used the Collision class. I don’t see any obvious shortcomings in the API, it just seems somewhat superfluous for most games. I found the Collisions API somewhat confusing to use, so merging parts of the Events and Collisions API might be helpful.-Andrew (MarioClone)

## Overlay ##
  * The Overlay API greatly benefited our group. Our game used many OverlayString and OverlayStat. The methods were well designed and the classes were well thought out. There was no strenuous work on our end. We essentially just created a String with the text we wanted to display or an Int with the value we wanted to display and then created a new Overlay with that variable as a parameter. Then using the setLocation and setFont methods we placed it where we needed it and in what style we needed it. One thing that could be improved is development of a class that is specifically an overlay button where it has an event occur. This could be facilitated with an EventListener inside of the OverlayString class. I think that this would be a very beneficial class because many games incorporate buttons in some manner especially on the menu screen. --Derek Zhou (Tower Defense)

  * Agreed.  This API is generally simple and worked for our group to use the score counter.  No issues here.  --Devon (Jumper)

  * We found the Overlay API very useful -- however, it seems to be competing with Player with regards to stat tracking. It makes more sense to keep track of stats as StatInt variables separate from the Player class as of right now, since they have to be of this type to be used by the Overlay package. I assume that we wrote our code incorrectly. Another issue we ran into using this API was the ability to change the color of the text in the OverlayStat class. While you can easily do this in OverlayString, it seemed like we had to extend OverlayStat to do the same.  --GalaxyInvaders

  * We didn't use Overlay because we ran out of time to implement scores, but we will be refactoring it in. From What I've seen, the overlay API looks very simple and easy to use. It might need to interface better with existing APIs that manage things like scores or stats, even if indirectly. (Tron)

  * One Overlay was used in DoodleGame to display the current score. This package was very helpful because Golden T provides poor support for displaying text on the game screen. The class Stat and StatInt should be utilized in the Player Classes for several reasons. First of all this will get rid of integers and other methods to increment those integers in Player, and also these StatInts inside of Player can then be passed into an Overlay and be displayed. -- Marcus Molchany (DoodleJump)

  * GTGE has SystemFont and BitmapFont API to do similar things as overlay system. “Jumper” used overlay API Stat to keep record of current score. It set new score in a update method, and drew it using GameFont API, which is GTGE integrated API. My suggestion would be add draw method in overlay system so that it’s a self-contained system. --Hao He (Cyberion)

  * As far as using the overlay system to handle click events on the overlays, it could be fairly easily implemented doing it as was done in the tower defense game.  But it might not be the best place to put it.  Since the player class controls events maybe it should be put in there.  Another possibility is to add the functionality to the event api where you can pass it a sprite and some method, and if there is say a click on the location of the sprite it performs some action. As for the comment that the overlayStat colors could not be change that was a understanding mistake in my understanding of how some Golden T classes behave.  It is fixed now and the setColor() method should work. –- Justin Goldsmith (Tower Defense)

  * The Overlay API was very useful for displaying the player’s stats on the screen. The only part of the package that was unclear was the OverlayPanel and, to a certain extent, the OverlayManager Panel. However, the OverlayString, OverlayStat and OverlayBar classes worked well for the purposes of our game. It was very easy to format, display, and update them. However, we were not really sure how the OverlayPanel works, or if it worked with Golden T in general. We tried implementing it a few ways but gave up and ended up using magic numbers for the location of the separate Overlays. One other solution for this was if the getWidth class returned the width of the overlay. Otherwise, the other Overlays work well. (Zombieland)

  * We found that the Overlay API was easy to use and simplified displaying our statistics on the screen. We used it to display things like the number of enemies remaining. However, the OverlayManager seems to overlap a bit with SpriteGroups. It would be very helpful if the benefits of using OverlayManager over a SpriteGroup were more carefully delineated.-Andrew Brown (MarioClone)

  * We had some trouble getting OverlayPanel to work with our game.  Also, there is overlap between Player and Overlay in that Player keeps track of certain values that could be taken care of in an overlay, such as the score.  Other than that, it’s a very useful class, and we used several overlays in our game. --Grandius team

  * The Overlay system is great, but I wish I didn't have to hardcode int values in for my Overlay locations in my XML file.  For example, I couldn't but an Overlay at "GAME\_HEIGHT". -Brian Simel

## Collisions ##
  * The Collisions API seems to have a lot of overhead to use (implementing Collidable for every object in question) without significantly reducing the amount of work required. Since we are are now dealing with Golden T and Sprites, I think CollisionManager or a subclass of CollisionManager inside the engine.collision package should work with Sprites automatically.  It also seems to me like the Collidable interface was created with the intention of creating a collision manager which would use the information Collidable requires to prevent the CollisionManager from having to loop through every possible Collidable object. Since this is not the case, Collidable seems unnecessary to me until such a CollisionManger is produced. I do not think that the Collisions API should be abandoned in deference to the collision managers in Golden T because those collision managers are built on the premise that they will be called every update and are a pain to set up if you only want to check for collisions occasionally (for instance making sure there is no overlap when placing a new Sprite in the game). --Daniel Koverman (Tower Defense)

  * Here's another group that didn't use the Collisions API but rather used the Golden T built-in collisions. As above, it seems that the API itself demands a lot more work than it actually saves. Furthermore, I was unclear if it supported pixel-perfect collisions, like Golden T's does.  (Tron)

  * Our team used Golden T’s collision API because VOOGA’s collision API doesn’t help ease our developing process. From my perspective, Golden T’s collision API handles collisions well. It offers all basic methods needed at least for our game. The VOOGA’s collision API offers collides(object1, java.util.List listOfObjects), which is nice because I need to build a player group in order to use Golden T’s collision API. Another question about collision is that until now, all our collisions are based on sprite images. I mean a collision is detected when the boarders of images collide. Can we detect collision based on sprites’ actual shape? It would be really useful if our collision API supports that. --Hao He (Cyberion)

  * Golden T's collision system was extremely useful to us when we were developing Jumper. Since each collision results in a different reaction depending on the type of block, we simply assigned each type of block a separate ID number and then specified each result in the DoodleToBlockCollision class based on that number. This seemed simple enough and so we did not end up using VOOGA's collision API. (Cody Kolodziejzyk, Jumper)

  * Since GoldenT has its own CollisionManager, we found the VOOGA one to be slightly redundant, and requiring of a lot more overhead code, such as implementing Collidable. We think that for the class to use this API instead of the built in GTGE collision system, it should provide some functionality beyond what GoldenT does, but we’re not sure what that would be. --GalaxyInvaders team

  * For some reason that I have yet to determine, I was almost completely unable to implement collision detection using Golden T's collision API and instances of both Golden T's and VOOGA's sprite APIs.  Golden T's API is supposed to be able to return a collision side for every collision (i.e., left to right or top to bottom), but this would never give an accurate result in our game.  Reverting the positions of sprites also appeared not to work well.  If I can get these issues resolved (which seems completely possible given the success other groups have had with this API), Golden T seems to make dealing with collisions very simple, though evidently not idiot proof. --David Herzka (MarioClone)

  * The Collisions API in VOOGA was not used in the Doodle Jump Game. The Golden T Game Engine Collision detection was much more simple to use because it makes comparisons using sprites. Unlike the Golden T Collision detection the VOOGA package requires that you state an object as a Collidable then the classes that check for collision can be applied. This implementation seems like there could be a loss in translation when a Collidable is in a collision but a Sprite of a Player or Item needs to be set to inactive. The API in VOOGA is extremely well written and organized, but Golden T provides everything that this package does with a very easy implementation. -- Marcus Molchany (DoodleJump)

  * We used the GoldenT collision manager rather than the vooga version because they share most functionalities while GoldenT’s collision manager provides much more control and capabilities that work directly with the game engine as it’s the native collision manager. While the idea behind both of the collision managers are similar, the vooga collision manager is general and allows for different types of objects without providing much specific functions, leaving the game designer to define the specifics. However, the GoldenT version of the collision manager proves to be more helpful as we were able to directly interact with the objects being passed in rather than defining the behavior in each object class, which would present other problems such as casting issues. The way Golden T design collision is that all types of collisions must extend the abstract collision class and each collision manager is directly associated with one or two sprite objects. The GoldenT collision system easily solve the problem of keeping track of collision types by delegating collision effects on specific sprites to distinct collision managers. (Zombieland)

  * The Collidable interface in the collision package would ensure a design pattern based approach. It would make sure that every object in the game handles its own collision with different objects, which is really good. However, what seems unclear is how this can be used in the actual game. For example, in Golden T once the collidable sprite groups are added to the playfield using the addCollisionGroup method, collisions between these groups are automatically checked for every time the playfield is updated. GoldenTCollisionManager class in the collision engine has a detectCollision method but how and where will this method/class be used? An explanation or example on how to use this would make the collision package very useful. Our team did not use this package in our game. --Grandius team